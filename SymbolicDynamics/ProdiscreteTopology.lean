/-

Main results:

-- the product topology on Y^X is generated by elementary cylinders of the form C(x, U) = {u: X → Y | u(x) ∈ U} where U is open
-- the prodiscrete topology on Y^X is generated by elementary cylinders of the form C(x, {y}) = {u: X → Y | u(x) = y}
-- basic results about the sets V(u, Ω) = {v: X → Y | u|Ω = v|Ω}
-- prove that {V(u, Ω) | Ω finite} forms a neighborhood base for u

TODO:

-- prove cylinders are clopen
-- cleanup the roundabout arguments

-/

import Mathlib.Topology.Bases
import Mathlib.Topology.Defs.Basic
import Mathlib.Topology.Constructions
import Mathlib.Topology.Compactness.Compact
import Mathlib.Topology.UniformSpace.Basic
import Mathlib.Topology.UniformSpace.Pi
import Mathlib.Topology.Separation
import Mathlib.Topology.Connected.TotallyDisconnected
import Mathlib.Topology.Metrizable.Basic
import Mathlib.Topology.Perfect
-- import Mathlib.Topology.Metrizable.Urysohn -- this introduces a lot of imports

-- the prodiscrete topology is the product of discrete spaces via the Π construction
/-
instance prodiscrete_space (G A: Type*) [TopologicalSpace A] [DiscreteTopology A]: TopologicalSpace (G → A) :=
  Pi.topologicalSpace
-/

variable {A T: Type*}

-- prodiscrete space is T0
instance prodiscrete_T0 [TopologicalSpace A] [DiscreteTopology A]:
  T0Space (T → A) := by
  exact Pi.instT0Space

-- prodiscrete space is T2 (Hausdorff)
instance prodiscrete_T2 [TopologicalSpace A] [DiscreteTopology A]:
  T2Space (T → A) :=
  Pi.t2Space

-- prodiscrete space is totally disconnceted
theorem prodiscrete_totally_disconnected [TopologicalSpace A] [DiscreteTopology A]:
  TotallyDisconnectedSpace (T → A) :=
  Pi.totallyDisconnectedSpace

-- discrete topology is regular
instance [TopologicalSpace A] [DiscreteTopology A]:
  RegularSpace A := by
  apply RegularSpace.of_exists_mem_nhds_isClosed_subset
  intro x U hU
  exists U
  constructor
  exact hU
  constructor
  simp
  rfl

-- the prodiscrete topology is regular
instance [TopologicalSpace A] [DiscreteTopology A]:
  RegularSpace (T → A) :=
  instRegularSpaceForall

theorem prodiscrete_T3 [TopologicalSpace A] [DiscreteTopology A]:
  T3Space (T → A) := by
  apply RegularSpace.t3Space_iff_t0Space.mpr
  exact prodiscrete_T0

/-
-- prodiscrete space is metrizable
theorem prodiscrete_metrizable [TopologicalSpace A] [DiscreteTopology A] [Finite A]:
  TopologicalSpace.MetrizableSpace (T → A) :=
  TopologicalSpace.metrizableSpace_of_t3_second_countable
-/

-- if A is finite then A^G is compact
theorem prodiscrete_compact [TopologicalSpace A] [DiscreteTopology A] [Finite A]:
  CompactSpace (T → A) :=
  Pi.compactSpace

/-
theorem prodiscrete_perfect [TopologicalSpace A] [DiscreteTopology A] [Finite A]:
  PerfectSpace (T → A) := by
  sorry
-/

-- projection map
def proj (t: T): (T → A) → A :=
  fun x => x t

def cylinder (t: T) (U: Set A): Set (T → A) :=
  Set.preimage (proj t) U

def elt_cylinder (t: T) (x: A): Set (T → A) :=
  cylinder t {x}

theorem elt_cylinder_eq (t: T) (a: A):
  cylinder t {a} = {x: T → A | x t = a} := rfl

theorem cylinder_open [TopologicalSpace A] (t: T) {U: Set A} (h: IsOpen U):
  IsOpen (cylinder t U) := by
  apply Continuous.isOpen_preimage
  exact continuous_apply t
  exact h

-- every cylinder in the prodiscrete topology is open
theorem prodiscrete_cylinder_open [TopologicalSpace A] [DiscreteTopology A]
  (t: T) (U: Set A): IsOpen (cylinder t U) := by
  simp [cylinder_open]

theorem cylinder_subset {G A: Type*} (g: G) {U1: Set A} {U2: Set A} (h: U1 ⊆ U2):
  cylinder g U1 ⊆ cylinder g U2 := by
  intro _ ha
  simp_all [cylinder, proj]
  exact h ha

/-
theorem cylinder_closed {G A: Type*} [TopologicalSpace A] [DiscreteTopology A] (g: G) (U: Set A):
  IsClosed (cylinder g U) := by
  sorry

theorem cylinder_clopen {G A: Type*} [TopologicalSpace A] [DiscreteTopology A] (g: G) (U: Set A): IsClopen (cylinder g U) :=
  ⟨cylinder_closed g U, cylinder_open g U⟩
-/

-- the set of cylinders
@[simp]
def cylinders (X I: Type*) [TopologicalSpace X]: Set (Set (I → X)) :=
  {C: Set (I → X) | ∃ i: I, ∃ U: Set X, IsOpen U ∧ C = cylinder i U}

-- the set of elementary cylinders
@[simp]
def elt_cylinders (X I: Type*): Set (Set (I → X)) :=
  {C: Set (I → X) | ∃ i: I, ∃ x: X, C = cylinder i {x}}

-- the set of "square cylinders"
@[simp]
def square_cylinders (X I: Type*) [TopologicalSpace X]: Set (Set (I → X)) :=
  {C | ∃ U: I → Set X, ∃ ι: Finset I, (∀ i ∈ ι, IsOpen (U i)) ∧ C = (Finset.toSet ι).pi U}

-- every cylinder is a union of elementary cylinders
theorem cylinder_union_of_elt_cylinders {X I: Type*} [TopologicalSpace X]
  {C: Set (I → X)} (h: C ∈ cylinders X I):
  ∃ i: I, ∃ U: Set X, C = ⋃ x ∈ U, cylinder i {x} := by
  simp at h
  obtain ⟨i, U, hC⟩ := h
  exists i, U
  simp [hC.right, cylinder]

-- every square cylinder is a finite intersection of cylinders
theorem square_cylinder_intersection_of_cylinders {X I: Type*} [TopologicalSpace X]
  {S: Set (I → X)} (h: S ∈ square_cylinders X I):
  ∃ ι: Finset I, ∃ U: ι → Set X, (∀ i: ι, IsOpen (U i)) ∧ S = Set.iInter (fun i: ι => cylinder (↑i) (U i)) := by
  obtain ⟨U, ι, h1, h2⟩ := h
  exists ι, Set.restrict ι U
  apply And.intro
  intro i
  apply h1 i
  simp
  rw [h2]
  ext
  simp [Set.mem_iInter]
  rfl

-- if X is discrete then the product topology on X^I is coarser than the topology generated by elementary cylinders
theorem pi_le_generateFrom_elt_cylinders {X I: Type*} [TopologicalSpace X] [DiscreteTopology X]:
  Pi.topologicalSpace ≤ TopologicalSpace.generateFrom (elt_cylinders X I) := by
  apply le_generateFrom
  intro C hC
  obtain ⟨i, x, hC2⟩ := hC
  rw [hC2]
  apply cylinder_open i
  simp

-- if X is discrete then the topology generated by elementary cylinders is coarse than the topology generated by open cylinders
theorem pi_generateFrom_cylinders_le_generateFrom_elt_cylinders {X I: Type*} [TopologicalSpace X] [DiscreteTopology X]:
  TopologicalSpace.generateFrom (elt_cylinders X I) ≤ TopologicalSpace.generateFrom (cylinders X I) := by
  apply le_generateFrom
  intro C hC
  obtain ⟨i, U, hC2⟩ := cylinder_union_of_elt_cylinders hC
  rw [hC2]
  -- ⊢ IsOpen (⋃ x ∈ U, cylinder i {x})
  -- #check @isOpen_iUnion (I → X) U (TopologicalSpace.generateFrom (elt_cylinders X I)) (fun x: U => cylinder i {x.val})
  -- apply @isOpen_iUnion
  -- fails due to type class inference
  sorry

-- the product topology is coarser than the topology generated by cylinders
theorem pi_le_generateFrom_cylinders {X I: Type*} [TopologicalSpace X]:
  Pi.topologicalSpace ≤ TopologicalSpace.generateFrom (cylinders X I) := by
  apply le_generateFrom
  simp
  intro _ i _ hU hC
  rw [hC]
  exact cylinder_open i hU

-- the topology generated by cylinders is coarser than the product topology
 theorem generateFrom_cylinders_le_pi {X I: Type*} [TopologicalSpace X]:
  TopologicalSpace.generateFrom (cylinders X I) ≤ Pi.topologicalSpace := by
  rw [pi_eq_generateFrom, cylinders]
  apply le_generateFrom
  intro S hS
  obtain ⟨ι, U, h1, h2⟩ := square_cylinder_intersection_of_cylinders hS
  rw [h2]
  apply @isOpen_iInter_of_finite (I → X) ι (TopologicalSpace.generateFrom (cylinders X I))
  intro i
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  exists i, U i
  constructor
  apply h1 i
  rfl

-- the product space is generated by cylinders
theorem pi_generateFrom_cylinders (X I: Type*) [TopologicalSpace X]:
  Pi.topologicalSpace = TopologicalSpace.generateFrom (cylinders X I) :=
  le_antisymm pi_le_generateFrom_cylinders generateFrom_cylinders_le_pi

-- if X is discrete then the product space is generated by elementary cylinders
theorem pi_generateFrom_elt_cylinders (X I: Type*) [TopologicalSpace X] [DiscreteTopology X]:
  Pi.topologicalSpace = TopologicalSpace.generateFrom (elt_cylinders X I) := by
  apply le_antisymm pi_le_generateFrom_elt_cylinders
  apply le_trans pi_generateFrom_cylinders_le_generateFrom_elt_cylinders
  exact generateFrom_cylinders_le_pi

-- neighborhood definition of continuity
-- TODO: replace with mathlib definition
theorem continuous_of_neighborhood_continuous {X Y: Type*} [TopologicalSpace X] [TopologicalSpace Y] {f: X → Y}:
  Continuous f ↔ (∀ x: X, ∀ V ∈ nhds (f x), ∃ U ∈ nhds x, Set.image f U ⊆ V) := by
  constructor
  intro h x V hV
  exists Set.preimage f V
  constructor
  rw [continuous_iff_continuousAt] at h
  specialize h x
  exact h hV
  simp
  intro h
  apply continuous_iff_continuousAt.mpr
  intro x V hV
  specialize h x V hV
  obtain ⟨U, hU1, hU2⟩ := h
  simp
  simp at hU2
  exact Filter.mem_of_superset hU1 hU2

def eqOn_nhd {G A: Type*} (x: G → A) (Ω: Set G): Set (G → A) :=
  {y | Set.EqOn x y Ω}

-- if Ω1 ⊆ Ω2 then eqOn_nhd(x, Ω1) ⊇ eqOn_nhd(x, Ω2)
theorem eqOn_nhd_incl {G A: Type*} (x: G → A) {Ω1: Set G} {Ω2: Set G} (h: Ω1 ⊆ Ω2):
  eqOn_nhd x Ω2 ⊆ eqOn_nhd x Ω1 :=
  fun _ hy _ hg => hy (h hg)

-- eqOn_nhd(x, G) = {x}
theorem eqOn_nhd_univ {G A: Type*} (x: G → A): eqOn_nhd x Set.univ = {x} := by
  simp [eqOn_nhd]

-- eqOn_nhd(x, ∅) = G → A
theorem eqOn_nhd_empty {G A: Type*} (x: G → A): eqOn_nhd x ∅ = Set.univ := by
  simp [eqOn_nhd]

-- x ∈ eqOn_nhd(x, Ω)
theorem eqOn_nhd_self {G A: Type*} (x: G → A) (Ω: Set G): x ∈ eqOn_nhd x Ω := by
  simp [eqOn_nhd, Set.EqOn]

-- eqOn_nhd(x, Ω) is equal to the intersection of all cylinders of the form C(g, x(g)) for g ∈ Ω
theorem eqOn_nhd_cylinder_eq {G A: Type*} (x: G → A) (Ω: Set G):
  eqOn_nhd x Ω = Set.sInter (Set.image (fun g => cylinder g {x g}) Ω) := by
  simp [cylinder, eqOn_nhd, Set.EqOn]
  ext
  rw [Set.mem_setOf_eq, Set.mem_iInter]
  apply Iff.intro
  · intros
    simp_all [proj]
  · intros
    simp_all [proj]

theorem eqOn_nhd_open {G A: Type*} [TopologicalSpace A] [DiscreteTopology A]
  (x: G → A) (Ω: Set G) (h: Finite Ω): IsOpen (eqOn_nhd x Ω) := by
  rw [eqOn_nhd_cylinder_eq]
  apply Set.Finite.isOpen_sInter
  apply Set.Finite.image
  exact h
  intro U
  simp
  intro _ _ hU
  rw [←hU]
  apply cylinder_open
  simp

theorem eqOn_nhd_is_nhd {G A: Type*} [TopologicalSpace A] [DiscreteTopology A]
  (x: G → A) (Ω: Set G) (h: Finite Ω):
  eqOn_nhd x Ω ∈ nhds x := by
  exact IsOpen.mem_nhds (eqOn_nhd_open x Ω h) (eqOn_nhd_self x Ω)

-- TODO: replace with mathlib definition
def neighborhood_base {X: Type*} [TopologicalSpace X] (x: X) (B: Set (Set X)): Prop :=
  B ⊆ (nhds x).sets ∧ ∀ V ∈ nhds x, ∃ U ∈ B, U ⊆ V

theorem cylinder_imply_singleton_mem {X Y: Type*} {x: X} {u: X → Y} {U: Set Y}
  (h: u ∈ cylinder x U): {u x} ⊆ U := by
  simp
  exact h

theorem eqOn_nhd_singleton_subset_cylinder {X Y: Type*} {x: X} {u: X → Y} {U: Set Y}
  (h: u ∈ cylinder x U): eqOn_nhd u {x} ⊆ cylinder x U := by
  rw [eqOn_nhd_cylinder_eq]
  simp
  exact cylinder_subset x (cylinder_imply_singleton_mem h)

theorem lemma0 {X Y Z: Type*} {f: X → Y → Z} {S: Set Z}
  (h2: S ⊆ {z | ∃ x y, z = f x y}):
  ∃ p: S → X × Y, ∀ z: S, f (p z).1 (p z).2 = z := by
  let p: S → X × Y := by
    intro ⟨s, hs⟩
    have h3 := h2 hs
    simp at h3
    let x := Classical.choose h3
    let h4 := Classical.choose_spec h3
    let y := Classical.choose h4
    exact (x, y)
  exists p
  simp
  intro z hz
  have h3 := h2 hz
  simp at h3
  let h4 := Classical.choose_spec h3
  let h5 := Classical.choose_spec h4
  rw [← h5]

theorem lemma1 {X Y Z: Type*} {f: X → Y → Z} {S: Set Z}
  (h2: S ⊆ {z | ∃ x y, z = f x y}):
  ∃ p1: S → X, ∃ p2: S → Y, ∀ z: S, f (p1 z) (p2 z) = z := by
  obtain ⟨p, hp⟩ := lemma0 h2
  exists fun z => (p z).1
  exists fun z => (p z).2

theorem lemma2 {A B C: Type*} {f: A → B → Set C} {X: Set (Set C)} (h1: Finite X) (h2: X ⊆ {C | ∃ x y, C = f x y}):
  ∃ p: Set (A × B), p.Finite ∧ X = Set.image (fun (x, y) => f x y) p := by
  have h1 : ∃ pick_x : X → A, ∃ pick_y : X → B,
    ∀ c : X, f (pick_x c) (pick_y c) = c := lemma1 h2
  obtain ⟨ pick_x, pick_y, hpick⟩ := h1
  exists Set.image (fun x => (pick_x x, pick_y x)) Set.univ
  constructor
  . apply Set.Finite.image
    apply Set.finite_univ
  . simp_all
    ext
    simp_all
    constructor
    · intro a
      constructor
      · constructor
        · constructor
          constructor
          constructor
          · constructor
            · rfl
            · rfl
          on_goal 3 => {
            simp_all
            rfl
          }
          · simp_all
    · intro a
      obtain ⟨_, h⟩ := a
      obtain ⟨_, h⟩ := h
      obtain ⟨left, right1⟩ := h
      obtain ⟨_, h⟩ := left
      obtain ⟨_, h⟩ := h
      obtain ⟨left, right2⟩ := h
      subst left right1 right2
      simp_all only

/-
the set {eqOn_nhd(x, Ω) | Ω finite} forms a neighborhood basis for x

Proof idea:

1. show for all x and Ω finite, eqOn_nhd(x, Ω) ∈ nhds x

2. show for every neighborhood N of x, there exists a finite set Ω such that eqOn_nhd(x, Ω) ⊆ N

-- every neighborhod of x contains a basic open set B containing x
-- every basic open set is a finite intersection of generating sets
-- generating sets are cylinders so we have x ∈ B = ∩_{i=1}^{n} C(g_i, U_i) where each U_i is open
-- let Ω := {g_i | i = 1, ..., n}
-- note that x ∈ C(g_i, U_i) for all i
-- from `cylinder_imply_singleton_mem` it follows that {x g_i} ⊆ U_i
-- from `cylinder_subset` it follows that C(g_i, {x g_i}) ⊆ C(g_i, U_i)
-- then:
-- V(x, Ω) = ∩_{i=1}^{n} C(g_i, x g_i)      by `eqOn_nhd_cylinder_eq`
           ⊆ ∩_{i=1}^{n} C(g_i, U_i)        by `cylinder_subset`
           = B
           ⊆ N
-/
theorem eqOn_nhd_forms_neighborhood_base {G A: Type*} [TopologicalSpace A] [DiscreteTopology A] (x: G → A):
  neighborhood_base x {U: Set (G → A) | ∃ Ω: Set G, Finite Ω ∧ U = eqOn_nhd x Ω } := by
  constructor
  . intro U hU
    simp_all
    obtain ⟨Ω, hΩ1, hΩ2⟩ := hU
    rw [hΩ2]
    exact eqOn_nhd_is_nhd x Ω hΩ1
  . intro V hV
    have h1 := TopologicalSpace.isTopologicalBasis_of_subbasis (pi_generateFrom_cylinders A G)
    obtain ⟨B, hB1, hB2, hB3⟩ := (TopologicalSpace.IsTopologicalBasis.mem_nhds_iff h1).mp hV
    obtain ⟨Cs, hCs⟩ := hB1
    simp at hCs
    have h2: ∃ params: Set (G × Set A), params.Finite ∧ Cs = Set.image (fun (gi, Ui) => cylinder gi Ui) params := lemma2 hCs.1.1 hCs.1.2
    obtain ⟨params, hparams⟩ := h2
    let Ω := Set.image (fun p => p.1) params
    exists Set.sInter (Set.image (fun g => cylinder g {x g}) Ω)
    simp
    constructor
    exists Ω
    constructor
    exact Set.Finite.image (fun p => p.1) hparams.1
    simp [eqOn_nhd_cylinder_eq]
    have h3: ∀ p ∈ params, cylinder p.1 {x p.1} ⊆ cylinder p.1 p.2 := by
      intro p hp
      apply cylinder_subset
      apply cylinder_imply_singleton_mem
      simp_all
      obtain ⟨_, right1⟩ := hCs
      obtain ⟨_, right2⟩ := hparams
      subst right1 right2
      simp_all
    have h4: ⋂ p ∈ params, cylinder p.1 p.2 = ⋂₀ Cs := by simp_all
    calc
      ⋂ g ∈ Ω, cylinder g {x g} = ⋂ p ∈ params, cylinder p.1 {x p.1} := by exact Set.biInter_image
                              _ ⊆ ⋂ p ∈ params, cylinder p.1 p.2 := by apply Set.iInter₂_mono; exact h3
                              _ = ⋂₀ Cs := h4
                              _ = B := hCs.2
                              _ ⊆ V := hB3

-- let x: G → A and let U be a neighborhood of x
-- then there exists finite Ω ⊆ G such that eqOn_nhd(x, Ω) ⊆ U
theorem exists_finite_eqOn_nhd {G A: Type*} [TopologicalSpace A] [DiscreteTopology A]
  {U: Set (G → A)} {x: G → A} (h: U ∈ nhds x):
  ∃ Ω: Set G, Finite Ω ∧ eqOn_nhd x Ω ⊆ U := by
  have := eqOn_nhd_forms_neighborhood_base x
  obtain ⟨V, hV1, hV2⟩ := this.right U h
  obtain ⟨Ω, hΩ1, hΩ2⟩ := hV1
  exists Ω
  constructor
  exact hΩ1
  rw [←hΩ2]
  exact hV2

def eqOn_entourage {A T: Type*} (Ω: Set T): Set ((T → A) × (T → A)) :=
  {(x, y)| Set.EqOn x y Ω}

theorem eqOn_entourage_subset {A T: Type*} {Ω1 Ω2: Set T} (h: Ω1 ⊆ Ω2): @eqOn_entourage A T Ω2 ⊆ @eqOn_entourage A T Ω1 := by
  intro (x, y) hxy
  exact Set.EqOn.mono h hxy

theorem eqOn_entourage_inter {A T: Type*} (Ω1 Ω2: Set T):
  @eqOn_entourage A T Ω1 ∩ @eqOn_entourage A T Ω2 = @eqOn_entourage A T (Ω1 ∪ Ω2) := by
  apply Set.Subset.antisymm_iff.mpr
  constructor
  intro _ h
  exact Set.EqOn.union h.left h.right
  apply Set.subset_inter
  exact eqOn_entourage_subset Set.subset_union_left
  exact eqOn_entourage_subset Set.subset_union_right

def eqOn_finite_entourages {A T: Type*}: Set (Set ((T → A) × (T → A))) :=
  {W | ∃ Ω: Set T, Finite Ω ∧ eqOn_entourage Ω = W}

theorem eqOn_finite_entourages_refl {A T: Type*}:
  ∀ W ∈ eqOn_finite_entourages, ∀ x : T → A, (x, x) ∈ W := by
  intro W hW x
  obtain ⟨Ω, hΩ⟩ := hW
  rw [←hΩ.right]
  exact Set.eqOn_refl x Ω

theorem eqOn_entourage_swap_eq {A T: Type*} (Ω: Set T):
  @eqOn_entourage A T Ω = Prod.swap ⁻¹' (eqOn_entourage Ω) := by
  ext
  exact Set.eqOn_comm

theorem eqOn_finite_entourages_symm {A T: Type*}:
  ∀ W ∈ @eqOn_finite_entourages A T, ∃ U ∈ eqOn_finite_entourages, U ⊆ Prod.swap ⁻¹' W := by
  intro W hW
  exists W
  constructor
  exact hW
  obtain ⟨Ω, hΩ⟩ := hW
  rw [←hΩ.right]
  exact (Set.Subset.antisymm_iff.mp (eqOn_entourage_swap_eq Ω)).left

theorem eqOn_entourage_comp_eq {A T: Type*} (Ω: Set T):
  compRel (@eqOn_entourage A T Ω) (eqOn_entourage Ω) = eqOn_entourage Ω := by
  apply Set.Subset.antisymm_iff.mpr
  constructor
  . intro ⟨x, z⟩ h
    obtain ⟨y, hy⟩ := h
    simp at hy
    exact Set.EqOn.trans hy.left hy.right
  . intro ⟨x, z⟩ h
    exists x
    exact ⟨Set.eqOn_refl x Ω, h⟩

theorem eqOn_finite_entourages_comp {A T: Type*}:
  ∀ W ∈ @eqOn_finite_entourages A T, ∃ U ∈ eqOn_finite_entourages, compRel U U ⊆ W := by
  intro W hW
  exists W
  constructor
  exact hW
  obtain ⟨Ω, hΩ⟩ := hW
  rw [←hΩ.right]
  exact (Set.Subset.antisymm_iff.mp (eqOn_entourage_comp_eq Ω)).left

def eqOn_finite_entourages_filter_base {A T: Type*}: FilterBasis ((T → A) × (T → A)) := {
  sets := eqOn_finite_entourages
  nonempty := sorry
  inter_sets := by
    intro U V hU hV
    obtain ⟨Ω, hΩ⟩ := hU
    obtain ⟨Ω', hΩ'⟩ := hV
    exists eqOn_entourage (Ω ∪ Ω')
    constructor
    exists Ω ∪ Ω'
    constructor
    exact Set.Finite.union hΩ.left hΩ'.left
    rfl
    rw [←hΩ.right, ←hΩ'.right]
    exact (Set.Subset.antisymm_iff.mp (eqOn_entourage_inter Ω Ω')).right
}

def eqOn_finite_entourages_uniformSpace_core {A T: Type*}: UniformSpace.Core (T → A) :=
  UniformSpace.Core.mkOfBasis
    eqOn_finite_entourages_filter_base
    eqOn_finite_entourages_refl
    eqOn_finite_entourages_symm
    eqOn_finite_entourages_comp

def eqOn_finite_entourages_uniformSpace (A T: Type*): UniformSpace (T → A) :=
  UniformSpace.ofCore eqOn_finite_entourages_uniformSpace_core

-- a uniform space is discrete if every set containing the diagonal is an entourage
class DiscreteUniformity (α: Type u) [UniformSpace α]: Prop where
  eq_principal_idrel: uniformity α = Filter.principal idRel

def prodiscrete_uniform_structure (A G: Type*) [UniformSpace A] [DiscreteUniformity A]:
  UniformSpace (G → A) := Pi.uniformSpace (fun _ => A)

-- theorem: the prodiscrete uniform space is the same as the one generated by eqOn_finite_entourages
theorem prodiscrete_uniform_structure_eq {A T: Type*} [UniformSpace A] [DiscreteUniformity A]:
  prodiscrete_uniform_structure A T = eqOn_finite_entourages_uniformSpace A T :=
  sorry

theorem prodiscrete_uniform_continuous_iff {A B T: Type*} [UniformSpace A] [DiscreteUniformity A]
  [UniformSpace B] [DiscreteUniformity B]
  {F: (T → A) → (T → B)}: UniformContinuous F ↔ (∀ Ω': Set T, Finite Ω' → ∃ Ω: Set T, Finite Ω ∧ Set.image (Prod.map F F) (@eqOn_entourage A T Ω) ⊆ (@eqOn_entourage B T Ω')) := by
  sorry
